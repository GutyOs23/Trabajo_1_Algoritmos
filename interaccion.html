<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Constructor de Grafos | Oscar Brandon Gutierrez Paz</title>
    <link rel="stylesheet" href="estilos.css">
    <style>
        /* Estilos adicionales espec√≠ficos para el constructor */
        .canvas-container {
            width: 100%;
            height: 500px;
            background: #0a0f0a;
            border: 3px solid #00ff00;
            border-radius: 15px;
            margin: 20px 0;
            box-shadow: 0 0 20px #00ff00;
            position: relative;
            overflow: hidden;
        }
        
        #grafoCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
        }
        
        .conexion-tag {
            display: inline-block;
            padding: 5px 12px;
            margin: 5px;
            border-radius: 20px;
            background: #0a1a0a;
            border: 2px solid;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <header>
        <div class="header-container">
            <div class="logo">
                <img src="imagenes/ucb_imagen.png" alt="Logo Universidad" onerror="this.style.display='none'">
            </div>
            <div class="info">
                <h1>Universidad Cat√≥lica Boliviana</h1>
                <p><strong>Estudiante:</strong> Oscar Brandon Gutierrez Paz</p>
                <p><strong>Asignatura:</strong> Analisis de Algoritmos</p>
                <p><strong>Docente:</strong> Yamil Vicente Miguel Cardenas</p>
            </div>
        </div>
    </header>

    <!-- Navegaci√≥n -->
    <div class="flex" style="justify-content: center; margin: 20px 0;">
        <a href="index.html" class="boton">√ÅLGEBRA</a>
        <a href="grafos.html" class="boton">GRAFOS</a>
    </div>

    <h1 class="main-title">CONSTRUCTOR DE GRAFOS</h1>
    
    <!-- Instrucciones r√°pidas -->
    <div class="instruccion">
        <p><strong>CLICK:</strong> Crea nodo | <strong>CLICK + CLICK:</strong> Conecta nodos | <strong>TECLA D + CLICK:</strong> Elimina nodo | <strong>ESC:</strong> Cancela</p>
    </div>

    <!-- Leyenda de colores -->
    <div class="leyenda">
        <span><span style="color:#ffaa00;"> A ‚Üí B</span> (naranja)</span>
        <span><span style="color:#44ff44;">B ‚Üí A</span> (verde)</span>
        <span><span style="color:#ff33ff;">Bucle</span> (rosado)</span>
    </div>

    <!-- PANEL DE CONTROL -->
    <div class="panel">
        <div class="flex" style="justify-content: center;">
            <!-- Tipo de conexi√≥n -->
            <div class="caja">
                <label>TIPO</label>
                <select id="tipoConexion">
                    <option value="unidireccional">‚û°Ô∏è UNIDIRECCIONAL</option>
                    <option value="bidireccional" selected>‚¨å BIDIRECCIONAL</option>
                    <option value="bucle">‚Üª BUCLE</option>
                </select>
            </div>
            
            <!-- UNIDIRECCIONAL -->
            <div id="panelUnaFlecha" style="display: none;" class="caja">
                <label>VALOR</label>
                <input type="number" id="valorUnico" value="1" min="0" step="0.5">
            </div>
            
            <!-- BIDIRECCIONAL -->
            <div id="panelDosFlechas" class="flex">
                <div class="caja" style="border-color: #ffaa00;">
                    <label style="color:#ffaa00;">A ‚Üí B</label>
                    <input type="number" id="valorAB" value="2" min="0" step="0.5" style="border-color: #ffaa00; color:#ffaa00;">
                </div>
                <div style="color:#00ff00; font-size: 24px;">‚¨å</div>
                <div class="caja" style="border-color: #44ff44;">
                    <label style="color:#44ff44;">B ‚Üí A</label>
                    <input type="number" id="valorBA" value="1" min="0" step="0.5" style="border-color: #44ff44; color:#44ff44;">
                </div>
            </div>
            
            <!-- BUCLE -->
            <div id="panelBucle" style="display: none;" class="caja">
                <label>VALOR BUCLE</label>
                <input type="number" id="valorBucle" value="1" min="0" step="0.5">
            </div>
            
            <!-- Color de nodo -->
            <div class="caja">
                <label>COLOR NODO</label>
                <select id="colorNodo">
                    <option value="#00ff00">Verde</option>
                    <option value="#ff3333">Rojo</option>
                    <option value="#3333ff">Azul</option>
                </select>
            </div>
        </div>
    </div>

    <!-- Bot√≥n limpiar -->
    <div style="text-align: center;">
        <button class="boton rojo" onclick="limpiarTodo()">LIMPIAR TODO</button>
    </div>

    <!-- Contadores -->
    <div class="info-bar">
        <span>üîµ NODOS: <span id="contadorNodos">0</span></span>
        <span>üü¢ CONEXIONES: <span id="contadorConexiones">0</span></span>
        <span>‚ö™ MODO: <span id="modoActual">Listo</span></span>
    </div>

    <!-- Canvas -->
    <div class="canvas-container">
        <canvas id="grafoCanvas"></canvas>
    </div>

    <!-- Lista de conexiones -->
    <div class="panel">
        <h3 style="color:#00ff00; text-align: center; margin-bottom: 15px;">üìã CONEXIONES ACTIVAS</h3>
        <div id="listaConexiones" style="text-align: center;"></div>
    </div>

    <script>
        // ===== VARIABLES =====
        let nodos = [];
        let conexiones = [];
        let siguienteId = 1;
        let nodoSeleccionado = null;
        let modoEliminar = false;
        
        const canvas = document.getElementById('grafoCanvas');
        const ctx = canvas.getContext('2d');
        
        // ===== INICIALIZAR =====
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            dibujarGrafo();
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // ===== CONTROL DE PANELES =====
        document.getElementById('tipoConexion').addEventListener('change', function() {
            const tipo = this.value;
            document.getElementById('panelUnaFlecha').style.display = tipo === 'unidireccional' ? 'block' : 'none';
            document.getElementById('panelDosFlechas').style.display = tipo === 'bidireccional' ? 'flex' : 'none';
            document.getElementById('panelBucle').style.display = tipo === 'bucle' ? 'block' : 'none';
        });
        
        // ===== EVENTOS DEL CANVAS =====
        canvas.addEventListener('click', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            if (modoEliminar) {
                eliminarNodo(x, y);
                modoEliminar = false;
                document.getElementById('modoActual').innerText = 'Listo';
                return;
            }
            
            const nodoClick = encontrarNodo(x, y);
            
            if (nodoClick) {
                if (nodoSeleccionado) {
                    crearConexion(nodoSeleccionado.id, nodoClick.id);
                    nodoSeleccionado = null;
                    document.getElementById('modoActual').innerText = 'Listo';
                } else {
                    nodoSeleccionado = nodoClick;
                    document.getElementById('modoActual').innerText = `Nodo ${nodoClick.id} seleccionado`;
                }
            } else {
                crearNodo(x, y);
            }
            
            dibujarGrafo();
        });
        
        // ===== TECLADO =====
        document.addEventListener('keydown', function(e) {
            if (e.key === 'd' || e.key === 'D') {
                modoEliminar = true;
                document.getElementById('modoActual').innerText = 'Click en nodo para eliminar';
                e.preventDefault();
            } else if (e.key === 'Escape') {
                nodoSeleccionado = null;
                modoEliminar = false;
                document.getElementById('modoActual').innerText = 'Listo';
                dibujarGrafo();
            }
        });
        
        // ===== FUNCIONES PRINCIPALES =====
        function crearNodo(x, y) {
            nodos.push({
                id: siguienteId++,
                x: x,
                y: y,
                color: document.getElementById('colorNodo').value,
                radio: 20
            });
            actualizarInfo();
        }
        
        function encontrarNodo(x, y) {
            return nodos.find(n => Math.hypot(x - n.x, y - n.y) < n.radio);
        }
        
        function crearConexion(origenId, destinoId) {
            const tipo = document.getElementById('tipoConexion').value;
            
            if (tipo === 'unidireccional') {
                const valor = parseFloat(document.getElementById('valorUnico').value);
                conexiones.push({
                    origen: origenId,
                    destino: destinoId,
                    valor: valor,
                    color: '#ffaa00',
                    id: Date.now() + Math.random()
                });
            } 
            else if (tipo === 'bidireccional') {
                const valorAB = parseFloat(document.getElementById('valorAB').value);
                const valorBA = parseFloat(document.getElementById('valorBA').value);
                
                // Flecha A ‚Üí B (naranja)
                conexiones.push({
                    origen: origenId,
                    destino: destinoId,
                    valor: valorAB,
                    color: '#ffaa00',
                    direccion: 'AB',
                    id: Date.now() + Math.random()
                });
                
                // Flecha B ‚Üí A (verde)
                conexiones.push({
                    origen: destinoId,
                    destino: origenId,
                    valor: valorBA,
                    color: '#44ff44',
                    direccion: 'BA',
                    id: Date.now() + Math.random() + 1
                });
            }
            else if (tipo === 'bucle') {
                const valor = parseFloat(document.getElementById('valorBucle').value);
                conexiones.push({
                    origen: origenId,
                    destino: origenId,
                    valor: valor,
                    color: '#ff33ff',
                    esBucle: true,
                    id: Date.now() + Math.random()
                });
            }
            
            actualizarInfo();
        }
        
        function eliminarNodo(x, y) {
            const nodo = encontrarNodo(x, y);
            if (nodo) {
                conexiones = conexiones.filter(c => c.origen !== nodo.id && c.destino !== nodo.id);
                nodos = nodos.filter(n => n.id !== nodo.id);
                
                if (nodoSeleccionado?.id === nodo.id) {
                    nodoSeleccionado = null;
                }
                
                actualizarInfo();
                dibujarGrafo();
            }
        }
        
        function limpiarTodo() {
            if (confirm('¬øEliminar todos los nodos y conexiones?')) {
                nodos = [];
                conexiones = [];
                siguienteId = 1;
                nodoSeleccionado = null;
                modoEliminar = false;
                actualizarInfo();
                document.getElementById('modoActual').innerText = 'Listo';
            }
        }
        
        function actualizarInfo() {
            document.getElementById('contadorNodos').innerText = nodos.length;
            document.getElementById('contadorConexiones').innerText = conexiones.length;
            actualizarListaConexiones();
            dibujarGrafo();
        }
        
        // ===== DIBUJAR - VERSI√ìN MEJORADA =====
        function dibujarFlecha(x, y, angulo, color) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angulo);
            ctx.fillStyle = color;
            ctx.shadowBlur = 15;
            ctx.shadowColor = color;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-20, -8);
            ctx.lineTo(-20, 8);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
        
        function dibujarGrafo() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Crear un mapa de pares de nodos para identificar bidireccionales
            const paresBidireccionales = new Map();
            
            // Agrupar conexiones por par de nodos
            conexiones.forEach(conn => {
                if (!conn.esBucle) {
                    const parId = `${Math.min(conn.origen, conn.destino)}-${Math.max(conn.origen, conn.destino)}`;
                    if (!paresBidireccionales.has(parId)) {
                        paresBidireccionales.set(parId, []);
                    }
                    paresBidireccionales.get(parId).push(conn);
                }
            });
            
            // Dibujar todas las conexiones
            conexiones.forEach(conn => {
                const origen = nodos.find(n => n.id === conn.origen);
                const destino = nodos.find(n => n.id === conn.destino);
                
                if (!origen || !destino) return;
                
                if (conn.origen === conn.destino) {
                    // BUCLE
                    ctx.beginPath();
                    ctx.strokeStyle = conn.color;
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]);
                    
                    ctx.moveTo(origen.x + 25, origen.y - 10);
                    ctx.quadraticCurveTo(origen.x + 60, origen.y - 70, origen.x - 15, origen.y - 40);
                    ctx.stroke();
                    
                    // Flecha del bucle
                    ctx.save();
                    ctx.translate(origen.x - 10, origen.y - 45);
                    ctx.rotate(-0.8);
                    ctx.fillStyle = conn.color;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-18, -8);
                    ctx.lineTo(-18, 8);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                    
                    // Valor del bucle
                    ctx.font = 'bold 16px monospace';
                    ctx.fillStyle = conn.color;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = conn.color;
                    ctx.fillText(conn.valor, origen.x + 45, origen.y - 65);
                } 
                else {
                    const parId = `${Math.min(conn.origen, conn.destino)}-${Math.max(conn.origen, conn.destino)}`;
                    const conexionesDelPar = paresBidireccionales.get(parId) || [];
                    const esBidireccional = conexionesDelPar.length >= 2;
                    
                    // Calcular √°ngulo base entre nodos
                    const anguloBase = Math.atan2(destino.y - origen.y, destino.x - origen.x);
                    
                    // Distancia entre nodos
                    const distancia = Math.hypot(destino.x - origen.x, destino.y - origen.y);
                    
                    // ===== SEPARACI√ìN MUCHO M√ÅS NOTABLE =====
                    // Aumentamos el factor de separaci√≥n
                    const separacion = Math.min(80, distancia * 0.45);
                    
                    if (esBidireccional) {
                        // ===== DOS V√çAS COMPLETAMENTE SEPARADAS =====
                        
                        // Vector perpendicular (normalizado)
                        const perpX = -(destino.y - origen.y) / distancia;
                        const perpY = (destino.x - origen.x) / distancia;
                        
                        // Puntos de control para las curvas - M√ÅS SEPARADOS
                        let ctrlX, ctrlY;
                        let anguloOffset;
                        
                        if (conn.color === '#ffaa00') {
                            // V√çA SUPERIOR (naranja) - A ‚Üí B - M√ÅS ARRIBA
                            anguloOffset = -0.5; // √Ångulo de salida m√°s pronunciado
                            ctrlX = (origen.x + destino.x) / 2 + perpX * separacion * 1.8;
                            ctrlY = (origen.y + destino.y) / 2 + perpY * separacion * 1.8;
                        } else {
                            // V√çA INFERIOR (verde) - B ‚Üí A - M√ÅS ABAJO
                            anguloOffset = 0.5; // √Ångulo de salida m√°s pronunciado
                            ctrlX = (origen.x + destino.x) / 2 + perpX * separacion * 1.8;
                            ctrlY = (origen.y + destino.y) / 2 + perpY * separacion * 1.8;
                        }
                        
                        // Calcular puntos de inicio y fin con offset pronunciado
                        let startX, startY, endX, endY;
                        
                        if (conn.color === '#ffaa00') {
                            // A ‚Üí B: sale muy arriba de A y llega muy arriba de B
                            startX = origen.x + Math.cos(anguloBase + anguloOffset) * origen.radio;
                            startY = origen.y + Math.sin(anguloBase + anguloOffset) * origen.radio;
                            endX = destino.x + Math.cos(anguloBase + Math.PI + anguloOffset) * destino.radio;
                            endY = destino.y + Math.sin(anguloBase + Math.PI + anguloOffset) * destino.radio;
                        } else {
                            // B ‚Üí A: sale muy abajo de B y llega muy abajo de A
                            startX = origen.x + Math.cos(anguloBase + anguloOffset) * origen.radio;
                            startY = origen.y + Math.sin(anguloBase + anguloOffset) * origen.radio;
                            endX = destino.x + Math.cos(anguloBase + Math.PI + anguloOffset) * destino.radio;
                            endY = destino.y + Math.sin(anguloBase + Math.PI + anguloOffset) * destino.radio;
                        }
                        
                        // Dibujar la curva
                        ctx.beginPath();
                        ctx.strokeStyle = conn.color;
                        ctx.lineWidth = 3;
                        ctx.setLineDash([]);
                        ctx.moveTo(startX, startY);
                        ctx.quadraticCurveTo(ctrlX, ctrlY, endX, endY);
                        ctx.stroke();
                        
                        // ===== FLECHA HASTA EL FINAL =====
                        // La flecha se dibuja en el punto final, justo en el borde del nodo
                        const arrowX = endX;
                        const arrowY = endY;
                        
                        // Calcular el √°ngulo de la flecha basado en la direcci√≥n de entrada al nodo
                        const anguloFlecha = Math.atan2(endY - ctrlY, endX - ctrlX);
                        
                        // Dibujar flecha justo en el borde del nodo
                        dibujarFlecha(arrowX, arrowY, anguloFlecha, conn.color);
                        
                        // Posici√≥n del valor (m√°s alejado de las l√≠neas)
                        const valorT = 0.5;
                        const valorX = (1-valorT)*(1-valorT)*startX + 2*(1-valorT)*valorT*ctrlX + valorT*valorT*endX;
                        const valorY = (1-valorT)*(1-valorT)*startY + 2*(1-valorT)*valorT*ctrlY + valorT*valorT*endY;
                        
                        ctx.font = 'bold 20px monospace';
                        ctx.fillStyle = conn.color;
                        ctx.shadowBlur = 12;
                        ctx.shadowColor = conn.color;
                        
                        // Posicionar el valor m√°s alejado
                        if (conn.color === '#ffaa00') {
                            ctx.fillText(conn.valor, valorX + 20, valorY - 35);
                        } else {
                            ctx.fillText(conn.valor, valorX - 40, valorY + 30);
                        }
                        
                    } else {
                        // CONEXI√ìN SIMPLE - UNA SOLA V√çA
                        
                        const startX = origen.x + Math.cos(anguloBase) * origen.radio;
                        const startY = origen.y + Math.sin(anguloBase) * origen.radio;
                        const endX = destino.x - Math.cos(anguloBase) * destino.radio;
                        const endY = destino.y - Math.sin(anguloBase) * destino.radio;
                        
                        ctx.beginPath();
                        ctx.strokeStyle = conn.color;
                        ctx.lineWidth = 3;
                        ctx.setLineDash(conn.color === '#ffaa00' ? [8, 4] : [4, 4]);
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Flecha justo en el borde del nodo
                        const arrowX = endX;
                        const arrowY = endY;
                        dibujarFlecha(arrowX, arrowY, anguloBase, conn.color);
                        
                        // Valor
                        const midX = (origen.x + destino.x) / 2;
                        const midY = (origen.y + destino.y) / 2;
                        
                        ctx.font = 'bold 20px monospace';
                        ctx.fillStyle = conn.color;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = conn.color;
                        ctx.fillText(conn.valor, midX, midY - 15);
                    }
                }
            });
            
            // Dibujar NODOS
            nodos.forEach(n => {
                if (nodoSeleccionado?.id === n.id) {
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, n.radio + 5, 0, Math.PI*2);
                    ctx.strokeStyle = '#ffffff';
                    ctx.setLineDash([5, 5]);
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                ctx.shadowBlur = 25;
                ctx.shadowColor = n.color;
                
                ctx.beginPath();
                ctx.arc(n.x, n.y, n.radio, 0, Math.PI*2);
                
                const gradient = ctx.createRadialGradient(n.x-5, n.y-5, 5, n.x, n.y, n.radio);
                gradient.addColorStop(0, n.color);
                gradient.addColorStop(0.8, '#003300');
                ctx.fillStyle = gradient;
                ctx.fill();
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2.5;
                ctx.stroke();
                
                ctx.shadowBlur = 10;
                ctx.font = 'bold 24px monospace';
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(n.id, n.x, n.y);
            });
            
            ctx.shadowBlur = 0;
        }
        
        // ===== LISTA DE CONEXIONES =====
        function actualizarListaConexiones() {
            const div = document.getElementById('listaConexiones');
            
            if (conexiones.length === 0) {
                div.innerHTML = 'No hay conexiones';
                return;
            }
            
            let html = '';
            conexiones.forEach(conn => {
                if (conn.origen === conn.destino) {
                    html += `<span class="conexion-tag" style="border-color:${conn.color}; color:${conn.color};">‚Üª ${conn.origen} = ${conn.valor}</span> `;
                } else {
                    const flecha = conn.color === '#ffaa00' ? '‚Üí' : '‚Üê';
                    html += `<span class="conexion-tag" style="border-color:${conn.color}; color:${conn.color};">${conn.origen} ${flecha} ${conn.destino} = ${conn.valor}</span> `;
                }
            });
            div.innerHTML = html;
        }
    </script>
</body>
</html>